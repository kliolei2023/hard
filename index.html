<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è¦ªå­é­”æ³•é¡ - é€äº®ç¾é¡ç‰ˆ</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft JhengHei', sans-serif; }
        
        /* å½±ç‰‡å±¤ï¼šé¡åƒé¡¯ç¤º */
        #input_video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
        }
        
        /* ç²’å­å±¤ */
        #canvas-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; pointer-events: none; 
        }
        
        /* UI å±¤ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* éš±è—å¼ç®¡ç†å€ (ç§»åˆ°åº•éƒ¨ï¼Œå¹½éˆæ¨¡å¼) */
        .admin-controls {
            position: absolute; bottom: 5px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 10px;
            pointer-events: auto; z-index: 300;
            box-sizing: border-box;
        }

        .btn-ghost {
            background: rgba(0,0,0,0.1); 
            border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.3);
            font-size: 10px; padding: 5px 8px; border-radius: 4px;
            cursor: pointer; transition: 0.3s;
            opacity: 0.2;
        }

        .btn-ghost:hover, .btn-ghost:active {
            opacity: 1; background: rgba(0,0,0,0.8); color: white; border-color: white; transform: scale(1.2);
        }

        /* ç›¸ç°¿å€ */
        .bottom-bar {
            position: absolute; bottom: 40px; 
            left: 0; width: 100%; height: 100px;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px);
            padding: 10px; pointer-events: auto; 
            display: flex; gap: 15px; overflow-x: auto; align-items: center; 
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .gallery-item {
            height: 80px; border: 2px solid white; border-radius: 12px; 
            flex-shrink: 0; cursor: pointer; transition: 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            object-fit: cover;
        }
        .gallery-item:hover { transform: scale(1.05); border-color: #ff9a9e; }

        #status-msg {
            position: absolute; bottom: 160px; width: 100%; text-align: center;
            color: white; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #ff0066;
            pointer-events: none;
        }

        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 180px; color: #fff; font-weight: bold; 
            text-shadow: 0 0 40px #ff0066; display: none; z-index: 200;
        }

        #review-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 1000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        #review-img {
            max-width: 90%; max-height: 80%; border: 8px solid #ffccea; border-radius: 20px;
            box-shadow: 0 0 60px rgba(255, 105, 180, 0.4);
        }
        .review-hint { color: #ffccea; margin-top: 20px; font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #ff0066; }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #3a1c71, #d76d77, #ffaf7b);
            z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <video id="input_video" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="status-msg">ç­‰å¾…é­”æ³•å•Ÿå‹•...</div>
        <div class="bottom-bar" id="gallery-scroller"></div>
        <div class="admin-controls">
            <button class="btn-ghost" onclick="clearGallery()">ğŸ—‘ï¸ æ¸…ç©º</button>
            <button class="btn-ghost" onclick="downloadAllPhotos()">ğŸ“¥ ä¸‹è¼‰</button>
        </div>
    </div>

    <div id="countdown">3</div>

    <div id="review-overlay" onclick="closeReview()">
        <img id="review-img" src="">
        <div class="review-hint">âœ¨ 3 ç§’å¾Œè‡ªå‹•ç¹¼çºŒ... âœ¨</div>
    </div>

    <div id="start-overlay">
        <h1 style="color:white; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.8); font-size: 40px;">ğŸ’–æè€å¸«çš„é­”æ³•é¡ ğŸ’–</h1>
        <p style="color: #fff; margin-bottom: 40px; font-size: 18px;">å’Œå®¶äººä¸€èµ·æ¯”å‡ºå¤§æ„›å¿ƒï¼Œæ‹å‡ºç¾å¥½å›æ†¶</p>
        <button class="btn-ghost" style="font-size: 24px; padding: 15px 60px; opacity: 1; background: white; color: #d76d77; border: none;" onclick="startApp()">é–‹å§‹é­”æ³•</button>
    </div>

    <script>
        let scene, camera, renderer;
        let mainParticles, bgParticles;
        let db;
        let isCounting = false, isReviewing = false;
        let handsActive = false;
        let handCenter = new THREE.Vector3(0, 0, 0);
        let reviewTimer = null, countdownTimer = null;
        
        const MAIN_COUNT = 3000;
        const BG_COUNT = 300;
        const HEART_SIZE = 3.8;
        const AGGREGATE_SPEED = 0.12;

        const mainOriginalPos = new Float32Array(MAIN_COUNT * 3);
        const mainTargetPos = new Float32Array(MAIN_COUNT * 3);

        const quotes = [
            "æ¯å€‹äººéƒ½æ˜¯å¤©æ‰ã€‚ä½†å¦‚æœä½ ç”¨ã€çˆ¬æ¨¹çš„èƒ½åŠ›ã€ä¾†åˆ¤æ–·ä¸€æ¢é­šï¼Œç‰ å°‡çµ‚å…¶ä¸€ç”Ÿè¦ºå¾—è‡ªå·±æ˜¯å€‹ç¬¨è›‹ã€‚â€”â€” æ„›å› æ–¯å¦",
            "æˆ‘å€‘ä¸éœ€è¦æŠŠå­©å­å¡‘é€ æˆæŸç¨®æ¨£å­ï¼Œæˆ‘å€‘åªéœ€è¦è®“ä»–å€‘æˆç‚ºä»–å€‘è‡ªå·±ã€‚â€”â€” è’™ç‰¹æ¢­åˆ©",
            "ä½ ä¹‹æ‰€ä»¥ç‰¹åˆ¥ï¼Œä¸æ˜¯å› ç‚ºä½ åšäº†ä»€éº¼ï¼Œè€Œæ˜¯å› ç‚ºä½ æ˜¯ä½ ã€‚â€”â€” éº¥æ–¯Â·è·¯å¡å¤š",
            "å­©å­ï¼Œä½ å°‡æœƒç§»å‹•å¤§å±±ï¼ä»Šå¤©å°±æ˜¯ä½ çš„æ—¥å­ï¼Œä½ çš„å±±å°±åœ¨å‰é¢ç­‰è‘—ä½ ï¼Œå‡ºç™¼å§ï¼â€”â€” è˜‡æ–¯åšå£«",
            "æ•™è‚²ä¸æ˜¯æ³¨æ»¿ä¸€æ¡¶æ°´ï¼Œè€Œæ˜¯é»ç‡ƒä¸€æŠŠç«ã€‚â€”â€” å¨å»‰Â·è‘‰æ…ˆ",
            "éŠæˆ²æ˜¯å­©å­çš„å·¥ä½œï¼Œä¹Ÿæ˜¯ä»–å€‘ç†è§£ä¸–ç•Œçš„æ–¹å¼ã€‚â€”â€” çš®äºå‚‘",
            "é‡è¦çš„ä¸æ˜¯ä½ ç¾åœ¨å¤šè°æ˜ï¼Œè€Œæ˜¯ä½ é¡˜æ„ä»˜å‡ºå¤šå°‘åŠªåŠ›å»å­¸ç¿’ã€‚â€”â€” å¡è˜¿Â·æœç¶­å…‹",
            "å­©å­æœ‰æ¬Šåˆ©çŠ¯éŒ¯ï¼Œå› ç‚ºé‚£æ˜¯æˆé•·çš„ä¸€éƒ¨åˆ†ã€‚â€”â€” é›…åŠªä»€Â·æŸ¯æœ­å…‹",
            "æˆ‘æ²’æœ‰å¤±æ•—ï¼Œæˆ‘åªæ˜¯ç™¼ç¾äº†ä¸€è¬ç¨®è¡Œä¸é€šçš„æ–¹æ³•ã€‚â€”â€” æ„›è¿ªç”Ÿ",
            "ä¸ç®¡ä½ èµ°å¾—å¤šæ…¢éƒ½æ²’é—œä¿‚ï¼Œåªè¦ä½ ä¸åœä¸‹ä¾†ã€‚â€”â€” å­”å­",
            "å‹‡æ•¢ä¸æ˜¯ä¸å®³æ€•ï¼Œè€Œæ˜¯é›–ç„¶å®³æ€•ï¼Œä½†é‚„æ˜¯å»åšäº†ã€‚â€”â€” ç´çˆ¾éœÂ·æ›¼å¾·æ‹‰",
            "æ„›æ˜¯æ•™è‚²çš„éˆé­‚ï¼Œæ²’æœ‰æ„›å°±æ²’æœ‰æ•™è‚²ã€‚â€”â€” æ–æ–¯æ³°æ´›é½Š",
            "æˆ‘æ„›ä½ ï¼Œä¸æ˜¯å› ç‚ºä½ å¾ˆä¹–æˆ–å¾ˆå„ªç§€ï¼Œè€Œæ˜¯å› ç‚ºä½ æ˜¯ä½ ã€‚",
            "è¬è¬ä½ ä¾†åˆ°é€™å€‹ä¸–ç•Œï¼Œåšæˆ‘çš„å­©å­ï¼Œé€™æ˜¯æˆ‘æœ€æ£’çš„ç¦®ç‰©ã€‚",
            "ä½ æ˜¯ç¨ä¸€ç„¡äºŒçš„ï¼Œé€™ä¸–ç•Œä¸Šæ²’æœ‰äººèƒ½å–ä»£ä½ çš„å…‰èŠ’ã€‚",
            "ç„¡è«–ç™¼ç”Ÿä»€éº¼äº‹ï¼Œå®¶æ°¸é æ˜¯ä½ æœ€æº«æš–çš„é¿é¢¨æ¸¯ã€‚",
            "æˆ‘çœ‹è¦‹ä½ éå¸¸åŠªåŠ›ï¼Œé€™æ¯”å¾—åˆ°æ»¿åˆ†æ›´è®“æˆ‘æ„Ÿåˆ°é©•å‚²ã€‚",
            "ä¸ç”¨è¿½æ±‚å®Œç¾ï¼Œåªè¦ä»Šå¤©çš„ä½ æ¯”æ˜¨å¤©é€²æ­¥ä¸€é»é»å°±å¥½ã€‚",
            "é€™ä»¶äº‹ä¸å®¹æ˜“ï¼Œä½†æˆ‘å–œæ­¡ä½ å …æŒæŒ‘æˆ°çš„æ¨£å­ã€‚",
            "æˆ‘ç›¸ä¿¡ä½ æœ‰èƒ½åŠ›è§£æ±ºé€™å€‹å•é¡Œï¼Œè©¦è‘—ç›¸ä¿¡è‡ªå·±ä¸€æ¬¡ï¼",
            "çŠ¯éŒ¯æ²’é—œä¿‚ï¼Œé‚£æ˜¯æˆ‘å€‘å¤§è…¦åœ¨å­¸ç¿’è®Šè°æ˜çš„è­‰æ˜ã€‚",
            "æƒ³å“­å°±å“­å‡ºä¾†å§ï¼Œæˆ‘æœƒé™ªåœ¨ä½ èº«é‚Šï¼Œç›´åˆ°ä½ å¥½ä¸€é»ã€‚",
            "å¤±æ•—ä¸¦ä¸å¯æ€•ï¼Œå®ƒåªæ˜¯æˆåŠŸçš„å½©æ’ï¼Œæˆ‘å€‘å†ä¾†ä¸€æ¬¡ã€‚",
            "å³ä½¿æˆ‘å€‘æ„è¦‹ä¸åŒï¼Œä½†æˆ‘é‚„æ˜¯å¾ˆæƒ³è½è½ä½ çš„æƒ³æ³•ã€‚",
            "ç´¯çš„æ™‚å€™è¨˜å¾—å›é ­çœ‹ï¼Œæˆ‘æ°¸é æ˜¯ä½ æœ€å¼·çš„å¾Œç›¾ã€‚",
            "ä½ çš„ç¬‘å®¹æ˜¯å®¶è£¡æœ€ç¾çš„é¢¨æ™¯ï¼Œçœ‹åˆ°ä½ é–‹å¿ƒæˆ‘ä¹Ÿå¥½é–‹å¿ƒã€‚",
            "æˆ‘å€‘ä¸€èµ·æƒ³è¾¦æ³•ï¼Œé€™æ¢è·¯ä¸Šä½ ä¸¦ä¸å­¤å–®ã€‚"
        ];
        
        const initDB = () => {
            return new Promise((resolve) => {
                const req = indexedDB.open("MagicMirrorDB", 1);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains("photos")) db.createObjectStore("photos", { autoIncrement: true });
                };
                req.onsuccess = (e) => {
                    db = e.target.result;
                    loadGallery();
                    resolve(db);
                };
            });
        };

        const savePhotoToDB = (base64) => {
            if (!db) return;
            const tx = db.transaction(["photos"], "readwrite");
            tx.objectStore("photos").add(base64);
            tx.oncomplete = loadGallery;
        };

        const loadGallery = () => {
            if (!db) return;
            const container = document.getElementById("gallery-scroller");
            container.innerHTML = "";
            const tx = db.transaction(["photos"], "readonly");
            tx.objectStore("photos").openCursor(null, 'prev').onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    const img = document.createElement("img");
                    img.src = cursor.value;
                    img.className = "gallery-item";
                    img.onclick = (ev) => { ev.stopPropagation(); showReview(img.src, false); };
                    container.appendChild(img);
                    cursor.continue();
                }
            };
        };

        const clearGallery = () => {
            if (!confirm("âš ï¸ è­¦å‘Šï¼šç¢ºå®šè¦åˆªé™¤æ‰€æœ‰ç…§ç‰‡å—ï¼Ÿ\n(æ­¤æ“ä½œç„¡æ³•å¾©åŸ)")) return;
            const tx = db.transaction(["photos"], "readwrite");
            tx.objectStore("photos").clear();
            tx.oncomplete = loadGallery;
        };

        const downloadAllPhotos = () => {
            const zip = new JSZip();
            const tx = db.transaction(["photos"], "readonly");
            let count = 0;
            tx.objectStore("photos").openCursor().onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    zip.file(`magic_heart_${Date.now()}_${count++}.png`, cursor.value.split(',')[1], {base64: true});
                    cursor.continue();
                } else {
                    if (count === 0) return alert("ç›¸ç°¿æ˜¯ç©ºçš„ï¼");
                    zip.generateAsync({type:"blob"}).then((content) => {
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = "ç²‰ç´…å›æ†¶.zip";
                        link.click();
                    });
                }
            };
        };

        async function startApp() {
            document.getElementById('start-overlay').style.display = 'none';
            await initDB();
            initThree();
            initMediaPipe();
        }

        function createHeartTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "white"; 
            ctx.beginPath();
            const x = 64, y = 64;
            ctx.moveTo(x, y + 30);
            ctx.bezierCurveTo(x - 50, y - 20, x - 50, y - 60, x, y - 40);
            ctx.bezierCurveTo(x + 50, y - 60, x + 50, y - 20, x, y + 30);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const heartTexture = createHeartTexture();

            const mainGeo = new THREE.BufferGeometry();
            const mainColors = new Float32Array(MAIN_COUNT * 3);
            const mainPositions = new Float32Array(MAIN_COUNT * 3);
            const mainPalette = [
                new THREE.Color('#ff0066'), new THREE.Color('#ff99cc'), 
                new THREE.Color('#ffcccc'), new THREE.Color('#ffffff'), new THREE.Color('#ff3333')
            ];

            for (let i = 0; i < MAIN_COUNT; i++) {
                mainOriginalPos[i*3] = (Math.random() - 0.5) * 350;
                mainOriginalPos[i*3+1] = (Math.random() - 0.5) * 250;
                mainOriginalPos[i*3+2] = (Math.random() - 0.5) * 100;
                
                mainPositions[i*3] = mainOriginalPos[i*3];
                mainPositions[i*3+1] = mainOriginalPos[i*3+1];
                mainPositions[i*3+2] = mainOriginalPos[i*3+2];

                const t = Math.random() * Math.PI * 2;
                const scale = HEART_SIZE + (Math.random() * 0.5);
                
                mainTargetPos[i*3] = (16 * Math.pow(Math.sin(t), 3)) * scale;
                mainTargetPos[i*3+1] = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * scale;
                mainTargetPos[i*3+2] = 0; 

                const c = mainPalette[Math.floor(Math.random() * mainPalette.length)];
                mainColors[i*3] = c.r; mainColors[i*3+1] = c.g; mainColors[i*3+2] = c.b;
            }

            mainGeo.setAttribute('position', new THREE.BufferAttribute(mainPositions, 3));
            mainGeo.setAttribute('color', new THREE.BufferAttribute(mainColors, 3));

            const mainMat = new THREE.PointsMaterial({
                size: 4.5, map: heartTexture, vertexColors: true, transparent: true,
                opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
            });

            mainParticles = new THREE.Points(mainGeo, mainMat);
            scene.add(mainParticles);

            const bgGeo = new THREE.BufferGeometry();
            const bgPositions = new Float32Array(BG_COUNT * 3);
            const bgColors = new Float32Array(BG_COUNT * 3);
            bgGeo.userData = { speeds: [], offsets: [] };

            for (let i = 0; i < BG_COUNT; i++) {
                bgPositions[i*3] = (Math.random() - 0.5) * 400;
                bgPositions[i*3+1] = (Math.random() - 0.5) * 300;
                bgPositions[i*3+2] = (Math.random() - 0.5) * 50; 

                const c = mainPalette[Math.floor(Math.random() * 3)];
                bgColors[i*3] = c.r; bgColors[i*3+1] = c.g; bgColors[i*3+2] = c.b;
                bgGeo.userData.speeds.push(0.05 + Math.random() * 0.1);
                bgGeo.userData.offsets.push(Math.random() * Math.PI * 2);
            }

            bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
            bgGeo.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));
            const bgMat = new THREE.PointsMaterial({
                size: 8.0, map: heartTexture, vertexColors: true, transparent: true,
                opacity: 0.4, blending: THREE.AdditiveBlending, depthWrite: false
            });

            bgParticles = new THREE.Points(bgGeo, bgMat);
            scene.add(bgParticles);

            animate();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isReviewing) return;

            const time = Date.now() * 0.002;
            const mainPos = mainParticles.geometry.attributes.position.array;

            for (let i = 0; i < MAIN_COUNT; i++) {
                let tx, ty, tz;
                if (handsActive) {
                    tx = handCenter.x + mainTargetPos[i*3];
                    ty = handCenter.y + mainTargetPos[i*3+1];
                    tz = mainTargetPos[i*3+2];
                } else {
                    tx = mainOriginalPos[i*3] + Math.sin(time + i) * 8;
                    ty = mainOriginalPos[i*3+1] + Math.cos(time + i * 0.8) * 8;
                    tz = mainOriginalPos[i*3+2];
                }
                mainPos[i*3]   += (tx - mainPos[i*3])   * AGGREGATE_SPEED;
                mainPos[i*3+1] += (ty - mainPos[i*3+1]) * AGGREGATE_SPEED;
                mainPos[i*3+2] += (tz - mainPos[i*3+2]) * AGGREGATE_SPEED;
            }
            mainParticles.geometry.attributes.position.needsUpdate = true;

            const bgPos = bgParticles.geometry.attributes.position.array;
            const speeds = bgParticles.geometry.userData.speeds;
            const offsets = bgParticles.geometry.userData.offsets;
            for (let i = 0; i < BG_COUNT; i++) {
                bgPos[i*3+1] += speeds[i] * 2;
                bgPos[i*3] += Math.sin(time + offsets[i]) * 0.1;
                if (bgPos[i*3+1] > 150) {
                    bgPos[i*3+1] = -150;
                    bgPos[i*3] = (Math.random() - 0.5) * 400;
                }
            }
            bgParticles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults((results) => {
                const statusEl = document.getElementById('status-msg');
                if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                    handsActive = true;
                    statusEl.innerText = "ğŸ’– ä¿æŒæ„›å¿ƒï¼Œæº–å‚™æ•æ‰ï¼ ğŸ’–";
                    statusEl.style.color = "#ffccea";

                    const h1 = results.multiHandLandmarks[0][9];
                    const h2 = results.multiHandLandmarks[1][9];
                    const mpMidX = (h1.x + h2.x) / 2;
                    const mpMidY = (h1.y + h2.y) / 2;
                    
                    handCenter.set((0.5 - mpMidX) * 280, (0.5 - mpMidY) * 200, 0);

                    const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    if (dist < 0.25) startCountdown();
                    else cancelCountdown();
                } else {
                    handsActive = false;
                    statusEl.innerText = "æè€å¸«ï¼šğŸŒ¸ ä¸€èµ·å’Œå®¶äººä¸€èµ·ä¼¸å‡ºé›™æ‰‹æ¯”å‡ºå¤§æ„›å¿ƒ ğŸŒ¸";
                    statusEl.style.color = "white";
                    cancelCountdown();
                }
            });

            const cameraObj = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 1280, height: 720
            });
            cameraObj.start();
        }

        function cancelCountdown() {
            if (!isCounting) return;
            isCounting = false;
            if (countdownTimer) clearInterval(countdownTimer);
            document.getElementById('countdown').style.display = 'none';
        }

        function startCountdown() {
            if (isCounting || isReviewing) return;
            isCounting = true;
            let count = 3;
            const cdEl = document.getElementById('countdown');
            cdEl.innerText = count;
            cdEl.style.display = 'block';
            if (countdownTimer) clearInterval(countdownTimer);
            countdownTimer = setInterval(() => {
                count--;
                if (count > 0) cdEl.innerText = count;
                else {
                    clearInterval(countdownTimer);
                    cdEl.style.display = 'none';
                    takePhoto();
                    isCounting = false;
                }
            }, 1000);
        }

        function takePhoto() {
            const video = document.getElementById('input_video');
            const canvas = document.createElement('canvas');
            canvas.width = renderer.domElement.width;
            canvas.height = renderer.domElement.height;
            const ctx = canvas.getContext('2d');

            const screenRatio = canvas.width / canvas.height;
            const videoRatio = video.videoWidth / video.videoHeight;
            let drawWidth, drawHeight, startX, startY;

            if (screenRatio < videoRatio) {
                drawHeight = canvas.height;
                drawWidth = drawHeight * videoRatio;
                startX = (canvas.width - drawWidth) / 2;
                startY = 0;
            } else {
                drawWidth = canvas.width;
                drawHeight = drawWidth / videoRatio;
                startX = 0;
                startY = (canvas.height - drawHeight) / 2;
            }

            ctx.save();
            ctx.translate(canvas.width, 0); 
            ctx.scale(-1, 1);
            ctx.drawImage(video, startX, startY, drawWidth, drawHeight);
            ctx.restore();

            ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);

            const w = canvas.width;
            const h = canvas.height;
            
            // --- éŸ¿æ‡‰å¼å­—é«”è¨ˆç®— ---
            const baseScale = w / 1000; 

            const topFontSize = Math.max(20, 26 * baseScale); 
            const dateFontSize = Math.max(16, 18 * baseScale); 
            const quoteFontSize = Math.max(18, 22 * baseScale); 
            
            const topBgH = topFontSize * 2.5; 
            const quoteBgH = quoteFontSize * 2.8;
            const dateBgH = dateFontSize * 2.5;

            const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // A. é ‚éƒ¨è–è¨€ (èƒŒæ™¯é€æ˜åº¦ 20%)
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
            ctx.fillRect(0, 0, w, topBgH);
            ctx.font = `bold ${topFontSize}px 'Microsoft JhengHei'`;
            ctx.fillStyle = "#0000FF";
            ctx.fillText("ã€Œè–è¨€æˆäº†è¡€è‚‰ï¼Œå¯„å±…åœ¨æˆ‘å€‘ä¸­é–“ã€‚ã€(è‹¥1ï¼š14)", w / 2, topBgH / 2);

            // B. åº•éƒ¨éš¨æ©Ÿèªå¥ (èƒŒæ™¯é€æ˜åº¦ 20%)
            const quoteY = h - quoteBgH;
            ctx.fillStyle = "rgba(255, 192, 203, 0.2)";
            ctx.fillRect(0, quoteY, w, quoteBgH);
            ctx.font = `bold ${quoteFontSize}px 'Microsoft JhengHei'`;
            ctx.fillStyle = "black";
            ctx.fillText(randomQuote, w / 2, quoteY + quoteBgH / 2);

            // C. åº•éƒ¨æ—¥æœŸ (èƒŒæ™¯é€æ˜åº¦ 20%)
            const dateY = quoteY - dateBgH;
            ctx.fillStyle = "rgba(255, 192, 203, 0.2)";
            ctx.fillRect(0, dateY, w, dateBgH);
            ctx.font = `bold ${dateFontSize}px 'Microsoft JhengHei'`;
            ctx.fillStyle = "white";
            ctx.fillText("2026å¹´1æœˆ10æ—¥è¦ªå¸«æ‡‡è«‡æ—¥", w / 2, dateY + dateBgH / 2);

            const dataURL = canvas.toDataURL('image/png');
            savePhotoToDB(dataURL);
            showReview(dataURL, true); 
        }

        function showReview(src, autoClose = false) {
            isReviewing = true;
            cancelCountdown();
            document.getElementById('review-img').src = src;
            const overlay = document.getElementById('review-overlay');
            overlay.style.display = 'flex';
            
            if (reviewTimer) clearTimeout(reviewTimer);
            if (autoClose) {
                reviewTimer = setTimeout(() => { closeReview(); }, 3000);
            }
        }

        function closeReview() {
            if (reviewTimer) clearTimeout(reviewTimer);
            document.getElementById('review-overlay').style.display = 'none';
            isReviewing = false;
        }

    </script>
</body>
</html>
